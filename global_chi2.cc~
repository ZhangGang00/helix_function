//#include "../faser_tracker/include/FaserTracker/TrackCandidate.hh"
//#include "../faser_tracker/include/FaserTracker/TrackFinder.hh"
//#include "../faser_tracker/include/FaserTracker/TrackFitter.hh"
//#include "../faser_tracker/include/FaserTracker/common_includes.hh"

#include "../faser_tracker/external/faserMC/faserMC/include/FaserTrackerGeometry.hh"
#include "../faser_tracker/external/faserMC/faserMC/include/FaserTrackerEvent.hh"
#include "../faser_tracker/external/faserMC/faserMC/include/FaserTrackerSpacePoint.hh"

#include <cstdlib>
#include <math.h>

#include "TROOT.h"
#include "TSystem.h"
#include "TChain.h"
#include "TFile.h"
#include "TGraph2D.h"
#include "TGraph.h"
#include "Math/Functor.h"
#include "Fit/Fitter.h"

#define Pi 3.1415926

double target_z[8]={0,50,910,960,1010,1060,1942,1992};
double points[10][2]={0};
int charge=1;

Double_t plane(Double_t *x, Double_t *par)
{
if ((par[0]<x[0] && x[0]<par[0]+3) || (par[1]<x[0] && x[0]<par[1]+3) || (par[2]<x[0] && x[0]<par[2]+3) || (par[3]<x[0] && x[0]<par[3]+3) || (par[4]<x[0] && x[0]<par[4]+3) || (par[5]<x[0] && x[0]<par[5]+3) || (par[6]<x[0] && x[0]<par[6]+3) || (par[7]<x[0] && x[0]<par[7]+3)) return 100.;
return -10000.;
}

void helix_fit(int& npar, double* deriv, double& f, double par[], int flag)
{
    double R = par[0];
    double x0 = par[1];
    double y0 = par[2];
    double z0 = 0;
    double phi = par[3];
    if (Pi < phi) phi = phi - 2*Pi;  // keep the same definition of angle in the following code
    double sin_lambda = std::sin(par[4]);
    double cos_lambda = std::cos(par[4]);
    double Cx = x0 - R*std::cos(phi);  // (Cx, Cz) are the coordinates of center of the circle 
    double Cz = z0 - R*std::sin(phi);

    double target_s=0,target_x=0,target_y=0;
    double chi2=0, error=0.08/sqrt(12);
    for (int i=0; i<8; i++) 
      {
    if (charge==1)  target_s = (std::asin((target_z[i] - Cz)/R) - phi)*R/(charge*cos_lambda);
    else if (std::sin(phi) >0) target_s = ((Pi-std::asin((target_z[i] - Cz)/R)) - phi)*R/(charge*cos_lambda);
    else target_s = ((-Pi-std::asin((target_z[i] - Cz)/R)) - phi)*R/(charge*cos_lambda);
    if (target_s<0) 
    { 
      cout<<"Error!!!  Negtive target_s !!!"<<endl; 
      chi2=1e20; 
      if (charge==-1) cout<<setprecision(9)<<R<<" "<<x0<<" "<<y0<<" "<<phi<<" "<<cos_lambda<<"  Cx="<<Cx<<"  Cz="<<Cz<<"  target_z="<<target_z[i]<<"  (Pi-std::asin((target_z[i] - Cz)/R))="<<(Pi-std::asin((target_z[i] - Cz)/R))<<endl; 
      else cout<<setprecision(9)<<R<<" "<<x0<<" "<<y0<<" "<<phi<<" "<<cos_lambda<<"  Cx="<<Cx<<"  Cz="<<Cz<<"  target_z="<<target_z[i]<<"  std::asin((target_z[i] - Cz)/R)="<<std::asin((target_z[i] - Cz)/R)<<endl;
    }
    target_x = Cx + R*cos(phi+charge*target_s*cos_lambda/R); 
    target_y = y0 + target_s*sin_lambda;

         chi2 += ((points[i][0] - target_x)*(points[i][0] - target_x) + (points[i][1] - target_y)*(points[i][1] - target_y)) / (error*error);	    
      }

    f = chi2;
}

int helix(vector <double>& outvect, double px, double py, double pz, double x0, double y0, double z0, double B, int charge, double target_z, double s)
{
  if (target_z==-9999 && s==-9999) {cout<<"Error!!!   Please clarify what to calculate"<<endl; return -1; }
  
  double p_perp = sqrt(px*px + pz*pz);  // The magnet field point to positive y axis
  double sin_lambda = py/sqrt(p_perp*p_perp + py*py); 
  double cos_lambda = p_perp/sqrt(p_perp*p_perp + py*py); 
  double R = 1000*p_perp/(0.3*B);  // R(mm), p(GeV), B(T)
  double vRx = -charge*pz/p_perp;  // vR is a norm vecter pointing from intial position to the center of the circle
  double vRz = charge*px/p_perp;
  double Cx = x0 + R*vRx;  // (Cx, Cz) are the coordinates of center of the circle  
  double Cz = z0 + R*vRz;
  double phi=0;  // -vR determines phi
  if (-vRx > 0) phi = std::asin(-vRz);
    else if (-vRz >0) phi = Pi - std::asin(-vRz);
    else phi =  -Pi - std::asin(-vRz);

  if (s != -9999) {
    outvect[0] = Cx + R*cos(phi+charge*s*cos_lambda/R);  //x 
    outvect[1] = y0 + s*sin_lambda;  //y
    outvect[2] = Cz + R*sin(phi+charge*s*cos_lambda/R);  //z
    //cout<<"SSS  CxCz"<<setprecision(9)<<Cx<<"  "<<Cz<<"  R="<<R<<"  phi="<<phi<<"  "<<charge*s*cos_lambda/R<<"  "<<sin(phi+charge*s*cos_lambda/R)<<"  "<<Cz + R*sin(phi+charge*s*cos_lambda/R)<<"  "<<outvect[2]<<endl;
    outvect[3] = -charge*p_perp*sin(phi+charge*s*cos_lambda/R); //px
    outvect[4] = py;  //py
    outvect[5] = charge*p_perp*cos(phi+charge*s*cos_lambda/R); //pz
  }
	
  if (target_z != -9999) {
    if (target_z-Cz > R) 
      {
	 cout<<"Warning!!!  target_z is outside the circle. target_z="<<target_z<<",  Cz="<<Cz<<",  R="<<R<<endl; 
	 return -1;
      }
    double target_s=0;
    if (charge==1)  target_s = (std::asin((target_z - Cz)/R) - phi)*R/(charge*cos_lambda);
    else if (-vRz >0) target_s = ((Pi-std::asin((target_z - Cz)/R)) - phi)*R/(charge*cos_lambda);
    else target_s = ((-Pi-std::asin((target_z - Cz)/R)) - phi)*R/(charge*cos_lambda);
    if (target_s<0) {cout<<"Error!!!  Negtive target_s !!!"<<endl; return -1; }
    outvect[0] = Cx + R*cos(phi+charge*target_s*cos_lambda/R); 
    outvect[1] = y0 + target_s*sin_lambda;
    outvect[2] = target_z;
    outvect[3] = -charge*p_perp*sin(phi+charge*target_s*cos_lambda/R); 
    outvect[4] = py;
    outvect[5] = charge*p_perp*cos(phi+charge*target_s*cos_lambda/R); 
  }

  return 0; 
}

void global_chi2(TString input) 
{
    gStyle->SetCanvasPreferGL(kTRUE);

    TFile inputFile(input.Data());

    TTree * eventTree = (TTree*) inputFile.Get("events");
    if (eventTree == nullptr) {
        cout << "ERROR  Unable to load event tree " << "\n"
             << "       Exiting.\n"
             << "\n";
        return ;
    }

    TTree * geoTree = (TTree*) inputFile.Get("geo");
    if (geoTree == nullptr) {
        cout << "ERROR  Unable to load event tree "<< "\n"
             << "       Exiting.\n"
             << "\n";
        return ;
    }
    long nGeoEntries = geoTree->GetEntries();
    if (nGeoEntries != 1) {
        cout << "ERROR  The geometry tree " << geoTree->GetName() << " has " << nGeoEntries << " entries.\n"
             << "       It should have exactly one entry. Exiting.\n"
             << "\n";
        return ;
    }

    FaserTrackerGeometry * geo = nullptr;
    geoTree->SetBranchAddress("geo", &geo);
    geoTree->GetEntry(0);
    FaserTrackerEvent * event = nullptr;
    eventTree->SetBranchAddress("events", &event);

    TGraph *g_xz = new TGraph();
    TGraph *g_yz = new TGraph();
    TPolyMarker3D *pm3D = new TPolyMarker3D();
    //for (int iEntry=0; iEntry<eventTree->GetEntries(); ++iEntry) { 
    for (int iEntry=0; iEntry<1; ++iEntry) 
      {
	int count=0;
        eventTree->GetEntry(iEntry);
        cout << "INFO  Processing event " << event->eventNumber << "\n";
        for (const FaserTrackerSpacePoint * sp : event->spacePoints) {
            const TVector3 & pos = sp->globalPos;
            cout << "      Read space point with global position (" << pos.X() << "," << pos.Y() << "," << pos.Z() << ")\n";
            g_xz->SetPoint(g_xz->GetN(), pos.Z(), pos.X());
            g_yz->SetPoint(g_yz->GetN(), pos.Z(), pos.Y());
            //pm3D->SetPoint(pm3D->GetN(), pos.X(), pos.Y(), pos.Z());
            pm3D->SetNextPoint(pos.Z(), pos.X(), pos.Y());
	    //cout<<"!!"<<pm3D->GetN()<<endl;
	    points[count][0]=pos.X();
	    points[count][1]=pos.Y();
	    count++;
        }
    }
double xx,yy,zz;
for (int i=0; i<g_xz->GetN(); i++) {g_xz->GetPoint(i,xx,yy); cout<<"g_xz: "<<xx<<"  "<<yy<<endl;}
for (int i=0; i<g_yz->GetN(); i++) {g_yz->GetPoint(i,xx,yy); cout<<"g_yz: "<<xx<<"  "<<yy<<endl;}
for (int i=0; i<pm3D->GetN(); i++) {pm3D->GetPoint(i,xx,yy,zz); cout<<"pm3D: "<<xx<<"  "<<yy<<"  "<<zz<<endl;}

        const int npar = 5;              // the number of parameters
        TMinuit minuit(npar);
        minuit.SetFCN(helix_fit);
	// minuit.DefineParameter(i, parName[i].c_str(), par[i], stepSize[i], minVal[i], maxVal[i])
	minuit.DefineParameter(0,"R",1e6,1e4,1e4,1e7);
	minuit.DefineParameter(1,"x0",0,1,-100,100);
	minuit.DefineParameter(2,"y0",0,1,-100,100);
	if (charge==1) minuit.DefineParameter(3,"phi0",0,0.01,-Pi/2,Pi/2);
          else minuit.DefineParameter(3,"phi0",3*Pi/4,0.01,Pi/2,3*Pi/2);
	minuit.DefineParameter(4,"lambda",0,0.01,-Pi,Pi);
	minuit.SetErrorDef(1);             
        minuit.SetMaxIterations(1000000);
        minuit.SetPrintLevel(1); //-1 no output, 1 standard output
	minuit.Migrad();
	double outpar[npar], err[npar];
        for (int i=0; i<npar; i++){
           minuit.GetParameter(i,outpar[i],err[i]);
           cout<<"par["<<i<<"] "<<outpar[i]<<"+/-"<<err[i]<<endl;
        }
        // Print results
        Double_t amin,edm,errdef;
        Int_t nvpar,nparx,icstat;
        minuit.mnstat(amin,edm,errdef,nvpar,nparx,icstat);
        cout<<"amin="<<amin<<"  edm="<<edm<<"  errdef="<<errdef<<"  nvpar="<<nvpar<<"  nparx="<<nparx<<"  icstat="<<icstat<<endl;
              
        double xMin = TMath::MinElement(g_xz->GetN(), g_xz->GetY());
        double xMax = TMath::MaxElement(g_xz->GetN(), g_xz->GetY());
        double yMin = TMath::MinElement(g_yz->GetN(), g_yz->GetY());
        double yMax = TMath::MaxElement(g_yz->GetN(), g_yz->GetY());
        double zMin = TMath::MinElement(g_xz->GetN(), g_xz->GetX());
        double zMax = TMath::MaxElement(g_xz->GetN(), g_xz->GetX());

	TPolyLine *pl_xz = new TPolyLine();
	TPolyLine *pl_yz = new TPolyLine();
        TPolyLine3D *pl3D2 = new TPolyLine3D();
	vector <double> outvect(6,0);
	int index=0;
	double si=0,xi=0,yi=0,zi=0;
        //int charge=-1;
	double B=0.5;
	double p_perp=0.3*B*outpar[0]/1000.0;
	double px=-charge*p_perp*sin(outpar[3]),py=p_perp*tan(outpar[4]),pz=charge*p_perp*cos(outpar[3]),x00=outpar[1],y00=outpar[2],z00=0;
        while (zi>=z00 && zi<zMax) {
	  helix(outvect,px,py,pz,x00,y00,z00,B,charge,-9999,si);
	  xi = outvect[0];
	  yi = outvect[1];
	  zi = outvect[2];
	  cout<<"pl3D2: si="<<si<<"  xi="<<xi<<"  yi="<<yi<<"  zi="<<zi<<"  px="<<outvect[3]<<"  py="<<outvect[4]<<"  pz="<<outvect[5]<<endl;
	  pl3D2->SetPoint(index,zi,xi,yi);
	  pl_xz->SetPoint(index,zi,xi);
	  pl_yz->SetPoint(index,zi,yi);
	  si += 1;
	  index++;
	}

	for (int i=0; i<8; i++) {
	helix(outvect,px,py,pz,x00,y00,z00,B,charge,target_z[i],-9999);
	cout<<"target_s="<<"  target_x="<<outvect[0]<<"  target_y="<<outvect[1]<<"  target_z="<<outvect[2]<<"  px="<<outvect[3]<<"  py="<<outvect[4]<<"  pz="<<outvect[5]<<endl;
	}
	
	TCanvas *c_xz = new TCanvas("fittedTrack_xz","",800,600);
	c_xz->cd();
        g_xz->SetMarkerStyle(20);
        g_xz->SetMarkerColor(kRed);
	g_xz->SetMarkerSize(1);
	g_xz->SetMarkerSize(1);
	g_xz->Draw("AP");
	pl_xz->SetLineWidth(2);
	pl_xz->SetLineColor(kYellow);
	pl_xz->Draw("same");
	// Add labels
        g_xz->SetTitle("");
        g_xz->GetXaxis()->SetTitle("z [mm]");
        g_xz->GetYaxis()->SetTitle("x [mm]");
        //g_xz->GetYaxis()->SetRangeUser(-100,100);
	c_xz->SaveAs("plots/fittedTrack_xz.eps");

        
	TCanvas *c_yz = new TCanvas("fittedTrack_yz","",800,600);
	c_yz->cd();
	gPad->SetLeftMargin(0.2);
        g_yz->SetMarkerStyle(20);
        g_yz->SetMarkerColor(kRed);
	g_yz->SetMarkerSize(1);
	g_yz->Draw("AP");
	pl_yz->SetLineWidth(2);
	pl_yz->SetLineColor(kYellow);
	pl_yz->Draw("same");
        g_yz->GetXaxis()->SetTitle("z [mm]");
        g_yz->GetYaxis()->SetTitle("y [mm]");
        //g_yz->GetYaxis()->SetRangeUser(-100,100);
	c_yz->SaveAs("plots/fittedTrack_yz.eps");

	TCanvas *c_xyz = new TCanvas("fittedTrack_xyz","",1200,600);
	c_xyz->cd();
	c_xyz->SetFillColor(kBlack);
	/*
        TView *view = TView::CreateView(1);
	//view->SetRange(xMin,yMin,zMin,xMax,yMax,zMax);
	//view->SetRange(yMin,zMin,xMin,yMax,zMax,xMax);
	view->SetRange(-200,zMin,-200,200,zMax,200);
	view->ShowAxis();
	TAxis3D *axis = TAxis3D::GetPadAxis();
	//TAxis3D::ToggleRulers();
        axis->SetLabelColor(kBlack);
        axis->SetAxisColor(kBlack);
        axis->SetTitleOffset(1.5);
        axis->GetXaxis()->SetTitle("Y [mm]");
        axis->GetYaxis()->SetTitle("Z [mm]");
        axis->GetZaxis()->SetTitle("X [mm]");
	//TAxis3D::ToggleRulers();
	*/
	TF2 *myPlane = new TF2("",plane,0,2000,-100,100,8);
	myPlane->SetParameters(0,50,910,960,1010,1060,1942,1992);
	myPlane->SetMaximum(100);
	myPlane->SetMinimum(-100);
        myPlane->SetNpy(10);// Make sure the plane will not get skipped by x-resolution effects
        myPlane->SetNpx(1000);
	myPlane->GetXaxis()->SetAxisColor(kWhite);
	myPlane->GetYaxis()->SetAxisColor(kWhite);
	myPlane->GetZaxis()->SetAxisColor(kWhite);
	myPlane->GetXaxis()->SetLabelColor(kWhite);
	myPlane->GetYaxis()->SetLabelColor(kWhite);
	myPlane->GetZaxis()->SetLabelColor(kWhite);
	myPlane->GetXaxis()->SetTitleColor(kWhite);
	myPlane->GetYaxis()->SetTitleColor(kWhite);
	myPlane->GetZaxis()->SetTitleColor(kWhite);
        myPlane->GetXaxis()->SetTitleOffset(2);
        myPlane->GetYaxis()->SetTitleOffset(2);
        myPlane->GetZaxis()->SetTitleOffset(1.5);
        myPlane->GetXaxis()->SetTitle("Z [mm]");
        myPlane->GetYaxis()->SetTitle("X [mm]");
        myPlane->GetZaxis()->SetTitle("Y [mm]");
	myPlane->Draw("lego4 0 fb bb");
        myPlane->SetFillColorAlpha(kGreen, 0.3);
        myPlane->SetLineColorAlpha(kGreen, 0.);
	
	
	pm3D->SetMarkerStyle(20);
	pm3D->SetMarkerSize(1);
	pm3D->SetMarkerColor(kRed);
	pm3D->Draw("same");

	pl3D2->SetLineWidth(3);
	pl3D2->SetLineColor(kYellow);
	pl3D2->Draw("same");

	TPaveText *pt = new TPaveText(0.85,0.9,0.95,0.98,"brNDC"); //(x1,y1,x2,y2)
        pt -> SetFillStyle(0);
        pt->SetBorderSize(0);
        pt->SetTextAlign(12);
        pt->SetTextSize(0.1);
        pt->SetTextColor(kGreen);
        pt->SetTextFont(62);
	pt->AddText("Faser");
	pt->Draw();
	//c_xyz->SaveAs("plots/fittedTrack_xyz.eps");

	inputFile.Close();
}

